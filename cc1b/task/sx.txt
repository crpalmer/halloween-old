*********************************
*********  PRELIMINARY **********
*********************************


SCENIX FEATURES SUPPORTED
-------------------------                                          

* up to 4096 words of code (8 code pages of 512 code words each)


* Scenix identification in header file:

    // these definitions are found in the header file for the device
    #pragma chip SX48, core 12 sx, code 4096, ram 10 : 0x10F
    #pragma chip SX28, core 12 sx, code 2048, ram 8 : 0xFF


* support of new instructions and new registers

    return;     // RET or RETI
    retp();     // RETP
    retiw();    // RETIW
    bank(n);    // BANK n
    iread();    // IREAD
    page(n);    // PAGE n

    MODE = n;   // M n
    MODE = W;   // MOV M,W
    MODE = b;
    W = MODE;   // MOV W,M
    b = MODE;

    DDRA = 10;
    PLP_A = 0x20;
    LVL_A = 0b01001111;

    DDRB = 0;
    PLP_B = 0x10;
    LVL_B = W;
    ST_B = 0;
    WKEN_B = 0xFF;
    WKED_B = 255;
    WKPND_B = 2;
    CMP_B = a;

    DDRC = 0;
    PLP_C = 0;
    LVL_C = 0x40;
    ST_C = 0xFF;


* It is possible to avoid updating the MODE resister, for example
  when this is set to a known value in a larger program region. The
  compiler will only optimize MODE register updating in instruction
  sequences that are not broken by CALL and JMP. The alternatives
  when using manual MODE register updating are inline assembly or
  built-in functions:

      MODE = 0x1F;      // set mode to certain value
      controlA(0x20);   // MOV W,#32 :  MOV !RA,W
      controlB(W);      //              MOV !RB,W
      controlC(a);      // MOV W,a   :  MOV !RC,W
      controlD(0);      // MOV W,#0  :  MOV !RD,W
      controlE(W);      //              MOV !RE,W


* interrupt support:

    interrupt server( void)
    {
        // interrupt service routine
    }


* FUSE and FUSEX configuration registers:

    Note that CF (FUSEX) must be set to 1 to disable CARRY as input
    to the ADD and SUB instructions. Otherwise some of the compiler
    generated code will not execute correctly.

    On SX20/28 the OPTIONX/STACKX (FUSE) should be set to 0 to
    enable the OPTION Register Extension and Stack Extension.
    Otherwise the compiler will not assume the correct number of
    stack levels.


    PRELIMINARY: CC1B does not support the FUSE and FUSEX register
    settings directly. However the #pragma cdata[] can be used:

      #pragma cdata[0x1010] = 0x7FA
      #pragma cdata[0x1011] = 0xF4B

    NOTE: The command line option -cd is required to compile the
    above statements.

    It is possible to simulate high level functionality by defining
    C macros (in a new file fuses.h):

      #define FUSE      cdata[0x1010]
      #define FUSEX     cdata[0x1011]
      #define TURBO     0x7FF
      #define FOSC_LP1  0xFDF & 0xFFD & 0xFFE // 000  LP crystal (32 Khz)
      #define STACKX    0xF7F  //STACK&OPTION register extension enable
      #define CF        0xFBF  //carry flag input to ADD and SUB
      #define CF_1      0xFFF  //no carry input to ADD and SUB

    Then it is possible to write:

      #pragma FUSE = TURBO & FOSC_LP1
      #pragma FUSEX = STACKX & CF_1



* PICmicro compatibility

   a) Option -Ax will change generated assembly to PICmicro format

   b) Automatically defined REGISTER names:
       PORTA, PORTB, ..,
       TRISA, TRISB, ..,
       INDF0, TMR0, PCL

   c) Inline assembly using PICmicro format (see INLINE.TXT in the
      CC5X package or the PDF manual for CC5X):

       #asm m+          // m+ enables PICmicro format
        MOVF a,W
        MOVWF b
       #endasm          // end current local setting

       #pragma asm default m+   // define new default setting

      NOTE: SX inline assembly formats are not yet implemented.


* automatic use of the PAGE instruction


* automatic use of the BANK instruction


* variables in 16 RAM banks

    - 2k devices: SX18/20/28:
       RAM ADDRESS    BANKED  INDIRECT
       0x000 - 0x007  no      yes    : special purpose registers
       0x008 - 0x00F  no      yes    : unbanked RAM
       0x010 - 0x01F  yes     yes    : RAM, bank 0 (16 byte)
       0x030 - 0x03F  yes     yes    : RAM, bank 1 (16 byte)
       0x050 - 0x05F  yes     yes    : RAM, bank 2 (16 byte)
       0x070 - 0x07F  yes     yes    : RAM, bank 3 (16 byte)
       0x090 - 0x09F  yes     yes    : RAM, bank 4 (16 byte)
       0x0B0 - 0x0BF  yes     yes    : RAM, bank 5 (16 byte)
       0x0D0 - 0x0DF  yes     yes    : RAM, bank 6 (16 byte)
       0x0F0 - 0x0FF  yes     yes    : RAM, bank 7 (16 byte)

    - 4k devices: SX48/52:
       RAM ADDRESS    BANKED  INDIRECT
       0x000 - 0x009  no      yes    : special purpose registers
       0x00A - 0x00F  no      yes    : unbanked RAM
       0x010 - 0x0FF  yes     yes    : RAM, bank 1 - 15 (16 byte each)
       0x100 - 0x10F  yes     no     : RAM, bank 0

    - using RAM banks:
       #pragma rambank 5    // 0 .. 15
       // variable definitions
       #pragma rambank 7
       // variable definitions
       #pragma rambank 0
       // variable definitions

       bank1 char aa;  // using bank type modifier


* 8 stack levels

    The FUSE register (address 0x1FFF) have to be set correctly
    during programming. The 2 stack level option requires setting
    the stack level right (#pragma). Using 8 stack levels is the
    recommended setting.


* additional optimization

    Optimal use of the BANK instruction
    Optimal use of the PAGE instruction
    Optimal use of the RETP instruction
    Optimal use of the M instruction



CURRENT LIMITATIONS (same as CC5X)
----------------------------------

  a) No linker support
  b) Restriction on expression complexity
  c) C syntax limitations
