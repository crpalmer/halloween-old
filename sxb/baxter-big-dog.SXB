' Baxter Big Dog
'
' One switch toggles between manual and auto modes.
' In manual mode, two buttons select 3 different behaviours for the dog.
' In auto mode, the three modes are picked randomly.
'
' The modes control 2 servos moving the head and tail.
' A Scary Terry audio controller drives a servo for the mouth.
'
' Audio is played via an AP-8.
'
' The audio and movement is repeated a random number of times (the audio
' is relatively short).

' I/O definitions

DEVICE SX28, OSCHS1, BOR26
FREQ 4_000_000
STACK 16  

LOAD "common.sxb"
LOAD "sio.sxb"

' ============ INPUTS ===============

BUTTON1  	PIN 	RB.0 INPUT
BUTTON2  	PIN 	RB.1 INPUT
OVERRIDE 	PIN 	RB.2 INPUT
PIR      	PIN 	RB.6 INPUT

' ============ OUTPUTS ==============

HEAD     	PIN 	RC.0 OUTPUT
TAIL     	PIN 	RC.1 OUTPUT

' ============ Constants ============

AUDIO:
DATA	 "!AP8%00"                   ' both address jumpers out

' ============ Variables =============

x1		VAR BYTE                                 ' temporary used throughout
playing		VAR BIT                          ' bit when temp is the AP-8 status
eeprom_base	VAR BYTE                        ' address of our current action in data table
R		VAR WORD                                  ' random


head_speed VAR BYTE                         ' current rate of movement for head
head_to VAR BYTE                            ' current destination of the head
tail_speed VAR BYTE                        ' current rate of movement for tail
tail_to VAR BYTE                            ' current destination of the tail
pirs VAR BYTE                               ' used to assure solid reading from the PIR (could be B0?)
reps VAR BYTE                               ' number of reps left for the action
	head_at VAR BYTE                           ' current position of the head
tail_at VAR BYTE                           ' current position of the tail

new_position FUNC	2,2

' Reset our state and get ready for the next action

PROGRAM start_waiting

start_waiting:

head_at = 150
tail_at = 150
head_to = head_at
tail_to = tail_at

IF OVERRIDE = 1 THEN waiting0

' If we are in auto mode then make sure we have a delay between triggers

'PAUSE 5000

waiting0:

pirs = 0

waiting:

RANDOM R               ' Keep the random number moving

IF OVERRIDE = 1 THEN manual

' Auto mode: if the PIR is low then reset the counter to 0.  If the PIR is high
' then increment the counter.  When we have accumulated enough positives in a row
' call it triggered.

IF PIR = 0 THEN waiting0
pirs = pirs + 1
IF pirs <= 250 THEN waiting

' Pick a random action and let is go

eeprom_base = R 
eeprom_base = eeprom_base & 3
eeprom_base = eeprom_base * 5
GOTO start

manual:

' Manual mode: two buttons control three actions.  If a button is pushed pause a
' little bit to make it easier to hit both buttoms at the same time.

eeprom_base = RB & %11
IF eeprom_base = 0 THEN waiting
PAUSE 100
eeprom_base = RB & %11
IF eeprom_base = 0 THEN waiting
eeprom_base = eeprom_base - 1
eeprom_base = eeprom_base * 5

start:

'reps = R // 3 + 2
reps = 1

' ================ main loop ===================
' Play audio
' Repeat until the audio is done (and head is reset)
'     if head is at destionation, pick new destination
'     if tail is at destination, pick new destination
'     move head and tail

rep:

IF reps = 0 THEN start_waiting
reps = reps - 1

x1 = eeprom_base + 4
READ MovementData + x1, x1
TX_STR AUDIO
TX_BYTE "P"
TX_BYTE "0" + x1

playing_loop:

' Head position

IF head_at = head_to THEN new_head
head_at = head_at + head_speed
GOTO handle_tail

' Head is at target, pick a new target in the opposite direction.

new_head:

READ MovementData + eeprom_base, head_speed
x1 = eeprom_base + 1
READ MovementData + x1, head_to

head_to = new_position head_to, head_speed
IF head_at > 150 THEN
  head_speed = - head_speed
  head_to = head_to - 150
  head_to = 150 - head_to   ' 150 - (head_to - 150)
endif


' Tail position

handle_tail:

IF tail_at = tail_to THEN new_tail
tail_at = tail_at + tail_speed
GOTO send_pulse

' Tail is at target, pick a new target in the opposite direction.

new_tail:

x1 = eeprom_base + 2
READ MovementData + x1, tail_speed
x1 = x1 + 1
READ MovementData + x1, tail_to

tail_to = new_position tail_to, tail_speed
IF tail_at > 150 THEN
  tail_speed = - tail_speed
  tail_to = tail_to - 150
  tail_to = 150 - tail_to  ' tail_to = 150 - (tail_to - 150)
ENDIF

' Send the positions to the servos

send_pulse:

'DEBUG #head_at, " ", #tail_at, CR
PULSOUT HEAD, head_at
PULSOUT TAIL, tail_at
PAUSE 18

' Check to see if the audio is finished

TX_STR AUDIO
TX_BYTE "G"
SERIN  SIO, BAUD, x1

IF playing = 0 THEN rep
GOTO playing_loop

FUNC new_position
  tmp1 VAR BYTE
  tmp2 VAR BYTE
  RANDOM R
  tmp1 = R_LSB // __PARAM1
  tmp2 = __PARAM1 / 2
  tmp1 = tmp1 + tmp2
  tmp1 = tmp1 + 1
  tmp1 = tmp1 MAX __PARAM1
  tmp1 = tmp1 * __PARAM2
  tmp1 = tmp1 + 150
  RETURN tmp1
ENDFUNC

' Movement is controlled by the following table.  The head and tail
' I ran out of room so I had to simplify movement somewhat from what I wanted.
' For a given action, the head and tail always move with the same increment (speed)
' each loop.  Random we pick how many steps of that size we take.
'
' That is, speed is the rate at which it moves and speed*steps is the maximum
' movement that can be made.

MovementData:
       ' head-speed   head-steps   tail-speed   tail-steps    track
DATA     5,            7,         1,           2,         1     'whine
DATA    20,            4,         3,           1,         0     'attack
DATA    30,            2,         20,          3,         3     'happy
DATA    15,	       8,	  5,	       2,	  0     'attack2